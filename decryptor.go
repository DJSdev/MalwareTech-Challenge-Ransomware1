package main

import (
	"crypto/sha1"
	"fmt"
	"os"
)

// This is going to be the basic type used for handling the image
type FileStruct struct {
	buff []byte
	size int
	hash []byte
}

// check() is for basic error handling and throws the exception
func check(e error) {
	if e != nil {
		panic(e)
	}
}

// ReadFile() types a directory string and returns a FileStruct with the essential a buffer, size	, and hash
// The buffer contains the data inside the file
// This is needed to compare files together to derive the key
func ReadFile(dir string) *FileStruct {

	imageStruct := FileStruct{}
	imageStructFile, err := os.Open(dir)
	check(err) // Leaving check(err) inside the function allows any stack trace to return from ReadFile instead of outside of it
	fileStats, _ := imageStructFile.Stat()
	imageStruct.size = int(fileStats.Size())
	imageStruct.buff = make([]byte, imageStruct.size)
	_, err = imageStructFile.Read(imageStruct.buff)
	check(err)
	hash := sha1.New()
	hash.Write(imageStruct.buff)
	imageStruct.hash = hash.Sum(nil)
	return &imageStruct
}

// WriteFile() works the inverse
func WriteFile(buff []byte, dir string) {
	fileToWrite, err := os.Create(dir)
	check(err)
	fileToWriteLength, err := fileToWrite.Write(buff)
	check(err)
	fmt.Printf("Wrote %d bytes to file to %s", fileToWriteLength, dir)
	fileToWrite.Sync()

}

func main() {

	const originalFileDir = "W7_Sample Pictures/Koala.jpg" // Downloaded from the internet
	const encrypteFileDir = "EncryptedFiles/Pictures/Sample Pictures/Koala.jpg_encrypted"
	originalFile := ReadFile(originalFileDir)
	encryptedFile := ReadFile(encrypteFileDir)

	// Since this is encrypted with a XOR cipher, the files being the same size may be a good indication they are the same and a key can be derived from one
	// If they aren't the same size, then it's likely the original picture is not one we can use to derive the key from
	if originalFile.size == encryptedFile.size {
		fmt.Printf("Original File Length: %d\nEncrypted File Length: %d\n", originalFile.size, encryptedFile.size)
		fmt.Printf("Files should be compatible\n")
	} else {
		panic("Files are not compatiable\n")
	}

	// Storing the key in keyBuff so we can use it later to decrypt the flag
	keyBuff := make([]byte, 32)
	for i := 0; i < 32; i++ {
		v2 := originalFile.buff[i]
		v3 := encryptedFile.buff[i]
		keyBuff[i] = v2 ^ v3
	}

	fmt.Printf("Key: %x\n\n", keyBuff)

	// Opened the encrypted flag and build a FileStruct of it
	encryptedFlagFile := ReadFile("EncryptedFiles/Documents/flag.txt_encrypted")

	// Create a second buffer to write the decryted flag into
	decryptedFlagBuff := make([]byte, encryptedFlagFile.size)

	// The index of keyBuff is selected by finding the remainder of "i % len(keyBuff)" to continually loop through the keyBuff contents by index
	for i := 0; i < encryptedFlagFile.size; i++ {
		decryptedFlagBuff[i] = keyBuff[i%len(keyBuff)] ^ encryptedFlagFile.buff[i]
	}

	fmt.Printf("%s\n\n", decryptedFlagBuff)

	WriteFile(decryptedFlagBuff, "decrypted_flag.txt")

}
